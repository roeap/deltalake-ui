// @generated by protoc-gen-es v1.3.1 with parameter "target=ts"
// @generated from file lakehouse/data/v1alpha1/api.proto (package lakehouse.data.v1alpha1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from message lakehouse.data.v1alpha1.SharingServerInfo
 */
export class SharingServerInfo extends Message<SharingServerInfo> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * @generated from field: string url = 4;
   */
  url = "";

  constructor(data?: PartialMessage<SharingServerInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "lakehouse.data.v1alpha1.SharingServerInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SharingServerInfo {
    return new SharingServerInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SharingServerInfo {
    return new SharingServerInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SharingServerInfo {
    return new SharingServerInfo().fromJsonString(jsonString, options);
  }

  static equals(a: SharingServerInfo | PlainMessage<SharingServerInfo> | undefined, b: SharingServerInfo | PlainMessage<SharingServerInfo> | undefined): boolean {
    return proto3.util.equals(SharingServerInfo, a, b);
  }
}

/**
 * @generated from message lakehouse.data.v1alpha1.ListSharingServersRequest
 */
export class ListSharingServersRequest extends Message<ListSharingServersRequest> {
  constructor(data?: PartialMessage<ListSharingServersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "lakehouse.data.v1alpha1.ListSharingServersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSharingServersRequest {
    return new ListSharingServersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSharingServersRequest {
    return new ListSharingServersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSharingServersRequest {
    return new ListSharingServersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListSharingServersRequest | PlainMessage<ListSharingServersRequest> | undefined, b: ListSharingServersRequest | PlainMessage<ListSharingServersRequest> | undefined): boolean {
    return proto3.util.equals(ListSharingServersRequest, a, b);
  }
}

/**
 * @generated from message lakehouse.data.v1alpha1.ListSharingServersResponse
 */
export class ListSharingServersResponse extends Message<ListSharingServersResponse> {
  /**
   * @generated from field: repeated lakehouse.data.v1alpha1.SharingServerInfo servers = 1;
   */
  servers: SharingServerInfo[] = [];

  constructor(data?: PartialMessage<ListSharingServersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "lakehouse.data.v1alpha1.ListSharingServersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "servers", kind: "message", T: SharingServerInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSharingServersResponse {
    return new ListSharingServersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSharingServersResponse {
    return new ListSharingServersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSharingServersResponse {
    return new ListSharingServersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListSharingServersResponse | PlainMessage<ListSharingServersResponse> | undefined, b: ListSharingServersResponse | PlainMessage<ListSharingServersResponse> | undefined): boolean {
    return proto3.util.equals(ListSharingServersResponse, a, b);
  }
}

/**
 * @generated from message lakehouse.data.v1alpha1.GetSharingServerRequest
 */
export class GetSharingServerRequest extends Message<GetSharingServerRequest> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<GetSharingServerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "lakehouse.data.v1alpha1.GetSharingServerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSharingServerRequest {
    return new GetSharingServerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSharingServerRequest {
    return new GetSharingServerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSharingServerRequest {
    return new GetSharingServerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSharingServerRequest | PlainMessage<GetSharingServerRequest> | undefined, b: GetSharingServerRequest | PlainMessage<GetSharingServerRequest> | undefined): boolean {
    return proto3.util.equals(GetSharingServerRequest, a, b);
  }
}

/**
 * @generated from message lakehouse.data.v1alpha1.GetSharingServerResponse
 */
export class GetSharingServerResponse extends Message<GetSharingServerResponse> {
  /**
   * @generated from field: lakehouse.data.v1alpha1.SharingServerInfo server = 1;
   */
  server?: SharingServerInfo;

  constructor(data?: PartialMessage<GetSharingServerResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "lakehouse.data.v1alpha1.GetSharingServerResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "server", kind: "message", T: SharingServerInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSharingServerResponse {
    return new GetSharingServerResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSharingServerResponse {
    return new GetSharingServerResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSharingServerResponse {
    return new GetSharingServerResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetSharingServerResponse | PlainMessage<GetSharingServerResponse> | undefined, b: GetSharingServerResponse | PlainMessage<GetSharingServerResponse> | undefined): boolean {
    return proto3.util.equals(GetSharingServerResponse, a, b);
  }
}

/**
 * @generated from message lakehouse.data.v1alpha1.QueryRequest
 */
export class QueryRequest extends Message<QueryRequest> {
  /**
   * @generated from field: string query = 1;
   */
  query = "";

  constructor(data?: PartialMessage<QueryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "lakehouse.data.v1alpha1.QueryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryRequest {
    return new QueryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryRequest {
    return new QueryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryRequest {
    return new QueryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryRequest | PlainMessage<QueryRequest> | undefined, b: QueryRequest | PlainMessage<QueryRequest> | undefined): boolean {
    return proto3.util.equals(QueryRequest, a, b);
  }
}

/**
 * @generated from message lakehouse.data.v1alpha1.QueryResponse
 */
export class QueryResponse extends Message<QueryResponse> {
  /**
   * @generated from field: bytes data = 1;
   */
  data = new Uint8Array(0);

  constructor(data?: PartialMessage<QueryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "lakehouse.data.v1alpha1.QueryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryResponse {
    return new QueryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryResponse {
    return new QueryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryResponse {
    return new QueryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryResponse | PlainMessage<QueryResponse> | undefined, b: QueryResponse | PlainMessage<QueryResponse> | undefined): boolean {
    return proto3.util.equals(QueryResponse, a, b);
  }
}

/**
 * @generated from message lakehouse.data.v1alpha1.GetTablesRequest
 */
export class GetTablesRequest extends Message<GetTablesRequest> {
  /**
   *
   * Specifies the Catalog to search for the tables.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   *
   * @generated from field: optional string catalog = 1;
   */
  catalog?: string;

  /**
   *
   * Specifies a filter pattern for schemas to search for.
   * When no db_schema_filter_pattern is provided, all schemas matching other filters are searched.
   * In the pattern string, two special characters can be used to denote matching rules:
   *    - "%" means to match any substring with 0 or more characters.
   *    - "_" means to match any one character.
   *
   * @generated from field: optional string db_schema_filter_pattern = 2;
   */
  dbSchemaFilterPattern?: string;

  /**
   *
   * Specifies a filter pattern for tables to search for.
   * When no table_name_filter_pattern is provided, all tables matching other filters are searched.
   * In the pattern string, two special characters can be used to denote matching rules:
   *    - "%" means to match any substring with 0 or more characters.
   *    - "_" means to match any one character.
   *
   * @generated from field: optional string table_name_filter_pattern = 3;
   */
  tableNameFilterPattern?: string;

  /**
   *
   * Specifies a filter of table types which must match.
   * The table types depend on vendor/implementation. It is usually used to separate tables from views or system tables.
   * TABLE, VIEW, and SYSTEM TABLE are commonly supported.
   *
   * @generated from field: repeated string table_types = 4;
   */
  tableTypes: string[] = [];

  /**
   * Specifies if the Arrow schema should be returned for found tables.
   *
   * @generated from field: bool include_schema = 5;
   */
  includeSchema = false;

  constructor(data?: PartialMessage<GetTablesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "lakehouse.data.v1alpha1.GetTablesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "catalog", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "db_schema_filter_pattern", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "table_name_filter_pattern", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "table_types", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "include_schema", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTablesRequest {
    return new GetTablesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTablesRequest {
    return new GetTablesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTablesRequest {
    return new GetTablesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetTablesRequest | PlainMessage<GetTablesRequest> | undefined, b: GetTablesRequest | PlainMessage<GetTablesRequest> | undefined): boolean {
    return proto3.util.equals(GetTablesRequest, a, b);
  }
}

/**
 * @generated from message lakehouse.data.v1alpha1.GetTablesResponse
 */
export class GetTablesResponse extends Message<GetTablesResponse> {
  /**
   * @generated from field: bytes data = 1;
   */
  data = new Uint8Array(0);

  constructor(data?: PartialMessage<GetTablesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "lakehouse.data.v1alpha1.GetTablesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTablesResponse {
    return new GetTablesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTablesResponse {
    return new GetTablesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTablesResponse {
    return new GetTablesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetTablesResponse | PlainMessage<GetTablesResponse> | undefined, b: GetTablesResponse | PlainMessage<GetTablesResponse> | undefined): boolean {
    return proto3.util.equals(GetTablesResponse, a, b);
  }
}

